# 前端搭建系列-模块
## 一、从开发一个模块说起

有时候组件和模块是一个不太好区分的概念，特别是在前端领域，大家对于功能、方法的划分粒度都有自己的理解。

在Angular里，module是一些类，函数或者值的集合。component则更像一个区块，比如某一段负责渲染模版到html的代码，多个component可以组成一个app。module之间可以相互引用，module也可以被component引用。

其实在web标准里，也可以看到一些相同的思路，比如ESM(EcmaScript modules)和Web Component，分别归属于ECMAScript规范和W3C规范。在极简的场景下，module负责提供一些方法，component负责渲染到页面上。

不过其实原本不需要太纠结这个问题，比如一个React Component发布到npm就是一个React module。只是在搭建的场景下，我们引入了组件和模块的概念。

* 组件：一个react component或者node.js module，在搭建体系下，都是一个组件；
* 模块：模块是组成页面的最小结构单位，一个模块会包含模版（jsx、xtpl等）、样式(CSS)、脚本逻辑、数据描述（data-schema）、模拟数据（mock-data）、表单描述（form-schema）、数据逻辑（faas-function）、依赖的描述（deps）等。一个模块甚至可以承接一个页面的逻辑。组件加上数据描述就是一个模块。

下图描述一个模块的生产流程：

![module-product.png](/assets/module-product.png)

## 二、从组件到模块

组件一直是一个比较纠结的事情。最理想的情况，不应该有组件的概念，“发送时要保守，接收时要开放”，原则上所有npm上的module，都应该低成本的引用。但实际上，低成本本身确是一个很大的挑战。搭建体系本身包含了从研发到线上渲染，所以必须得思考和解决下面的问题：

1. 模块如何引用组件？
2. 如何合理引入npm的资源？
3. 如何引入和编译本地文件系统里的文件？
4. 如何渲染一个页面？

## 三、如何解决研发问题

### 3.1 模块、组件之间的引用

在很多年前，模块加载器是前端工程里非常重要的一部分。加载器本质上就是通过一个去中心化的引用关系来描述细粒度模块之间的依赖，开发者使用模块A的时候，只需要声明我依赖模块A，而模块A本身依赖来模块B，是在模块A自己内部管理的。在最终浏览器端，加载器把一个个引用关系进行合并，最后用合并后的引用关系表来生成一串combo url。

引用关系实际对应的就是搭建体系里的seed文件。seed本身算是一个比较古老的设计，从YUI时代（或者可能更早）就已经有seed的概念。

```js
YUI({
  modules: {
    one: {
      async: false,
      fullpath: './one.js'
    },
    two: {
      async: false,
      fullpath: './two.js',
      requires: ['one']
    }
  }
}).use('two', function(Y) {
  // Module one &amp; two are loaded now.
});
```

因为有一份这样的依赖描述，也可以通过同名取最新版本的策略，来做到同名模块只会加载一次，一定程度上解决js体系过大的问题。同时，如果开发者有能力或者有一个好的策略对combo url进行管理，是可以做到多页面之间共享资源缓存的，提升全链路的用户体验。

这种依赖关系的设计方案，在搭建服务需要具备seed处理的能力，可以在服务端去重输出代码bundle，这部分在Native的情况下还是有重要作用。

![module-invoke.png](/assets/module-invoke.png)

### 3.2 如何引入npm的资源

npm上还没有成熟的前端模块托管方案（那个时候还是browserify盛行的时代），早期相对比较封闭的体系，所有的组件、模块都需要发布到制定的一个源下。

随着webpack时代的到来，把前端组件发布到npm已经是托管的最佳实践。早期体系本身构建比较简单，对构建依赖较小，基本上只是babel + CMD wrap，将react和babel-polyfill的开源组件发布到搭建的组件仓库源下，在技术方案收敛和统一的前提下，和社区体系快速融合是较好的方案。

采用这种开源组件在内部组件结合发布到搭建平台的情况下，但是对于内部横向技术体系要结合的话，暴露了问题，就是巨大的组件都要单独再发一份，虽然我们可以提供一个自动的npm组件发布到搭建体系的工具，但也只是把手动步骤改成半自动，本质上的问题也没有解决，并且引入的npm组件内部可能有更深度的依赖，要不就是引入npm组件连带需要引入n个依赖组件，要不就是打包，还存在重复代码。总之，npm模块的引入，在缺少页面级构建的情况下，是有点管理失控的。

优化的方向，可以把大部分的内部组件都迁移一份到npm中，不过由于每个组件都有一个seed文件，依赖和社区的组件存在隔离。这块是需要继续探索与社区方案结合。

### 3.3 如何引入和编译本地文件系统里的文件

为了维护方便，组件内部会对文件进行拆分，组件src目录下可能会有比较复杂的文件目录结构，在原有的体系下，每个文件都会在seed里生成一份module的声明。随着业务复杂度的提升，以及搭建场景的不可控，仅一个页面的合并后的seed文件大小可能会超过50KB。

为了对文件进行合理的合并，对单个组件的构建引入了webpack，维护时可以是多文件，对外暴露接口的时候单一文件，有点类似package.json里main字段的作用。为了避免webpack把package.json dependences里声明的依赖都打包到组件内部，构建器里会维护一份白名单，白名单内的都属于搭建体系内已有的组件，可以直接通过依赖关系引用，而不需要打包到组件bundle内部。

### 3.4 如何渲染页面
搭建体系统一提供的一个页面渲染引擎Node服务，一个页面发布到Node服务上，实际只是发布了页面和组件、模块之间的引用关系，真正渲染的时候进行一次实时的“构建”。这里原本应该用“组装”这个词，但是随着端侧渲染方案的不断升级，Node服务提供了超出纯粹组装的能力，而更像是一个实时的构建器。

![render-page-server.png](/assets/render-page-server.png)

开发者可以选择在服务端模版引用一个组件

```js
{{ require(["@ali/common/index.css"]) }}
```

这样就会在页面文档结构里插入一段script
也可以选择在浏览器端加载一个组件：

```js
var customEvent = require("@ali/custom-event/index");
```

这样的话，如果这个组件没有在引用之前加载，就会通过异步脚本的方式把这个模式加载进来。
而Node服务也可以提供placeholder能力来满足各种不通的模块内容输出方式。

最典型的就是js的输出能力，比如`placeholder("js")`
默认选项`placeholder("js", noTag=false, noSeed=false, needCalculate=false)`

计算页面的js资源依赖。默认会生成script标签，并且会带上计算完成的seed依赖。

noTag选项允许不直接生成script标签，而是输出依赖的combouri，再由前端异步载入JS资源。

noSeed，seed体积很大，某些场景不需要输出seed，可以通过noSeed选项关闭
needCalculate，开启后会计算依赖的依赖，默认不开启时只会解析一层依赖。

而`placeholder("native")`主要用于native场景，和js类似，不同的是native下会把依赖的JS资源的内容直接输出，而不是输出combouri的链接。

## 四、带来的问题

### 4.1 页面数量带来的问题

业务有个特点，就是页面数量多，每次参与搭建的页面可能成百上千个，线上活跃的页面数量也是非常多，并且因为业务域存在一些管理，统一的诉求，一批页面之间存在共享的区块、Solution、片段来保证批量生效。最典型的场景就是页面的底部导航这种，还有就是自动上下线，不同时期的切换等。

页面数量大，不是让开发者简单开发几个应用仓库就可以满足，也就直接导致跟社区化的构建方式有差别。整个工程体系的复杂度也不是在构建本身的复杂，而是在资源管理上，所以也不是选择webpack或者不选webpack可以解决的。

采用一个实体页面+多份数据来实现一批页面的方式，是一个非常不错的实践，本质上就是通过页面模版的能力，一方面约束可用的模块范围，另一方面模版本身和应用已经有一些相似点，对模版的优化可以解决很多线上渲染时难以解决的问题。

### 4.2 开源组件本身带来的风险

因为npm本身相对还是比较自由，大部分开发还是依赖自己的判断在使用大量的开源组件，可能是Node端，也可能是消费者端，但是自由背后还是有蛮多的安全风险，比如之前出现的event-stream模块加入来盗取比特币钱包的代码，以及近期purescript发现有恶意代码，以及可能的开源组件带来的版权风险。盲目使用开源组件的风险比想象的大，如果要用到开源组件，需要单独在内部同步一份，方便进行安全生产扫描。虽然对开发者来说不太友好，但是运行在用户设备上的代码，基本的安全策略还是要有的。

其实组件还有更多的问题，包括来自npm组件内部依赖非常深，内部组件打包的时候会直接打包到组件代码里，会造成重复的代码，在条件可允许的情况下，尽量让运行的代码在自己可控的范围内。

### 4.3 模块要低耦合

如前面描述，一个模块会包含模版（jsx、xtpl等）、样式（css）、脚本逻辑、数据描述（data-schema）、模拟数据（mock-data）、表单描述（form-schema）、依赖的描述（seed、deps）等。比组件多出来的这些文件分别是做什么的。

* 数据描述：参考了json schema规范，描述了当前模块渲染依赖的数据格式，原本应该是拿来做数据校验用。为了简化开发者成本，既用于数据校验，又用于投放生成用户填写数据的表单。不过随着TS的普及，未来schema是可以根据ts描述自动生成，也算是降低开发者的成本。

* 模拟数据：模拟数据一方面是本地调试用，也用于模块第一次拖入页面的时候，可以给用户展示一份默认的数据。

* 表单描述：用于描述用户生成数据的表单，这里会有一些用户群体不同带来的差别，主要是给业务便于理解的填写真正模块需要渲染的依赖数据。

表单描述目前还未作为一个基础能力，由搭建应用自己扩展。

一个符合低耦合标准的模块，应该是：

1. 数据描述符合标准数据源规范，目前定义一些基础的数据模型，后续也会有统一的模型中心来进行平台化的约束；
2. 模块不应该直接调用上下文环境里的变量，比如window.xxx等，如果依赖一些工具函数，应该走依赖组件的方式引入；
3. 模块间应该减少或者没有通信，必须通信的地方依赖solution转发实现。

不过上面的描述还是偏理想的，不过随着平台能力的补齐，这部分未来不会成为一个需要让开发者纠结的问题。

### 4.4 模块规范

搭建本质上是通过组件和模块实现低代码或者无代码的生产解决方案。通过这个解决方案，活动体系、频道体系、国际化体系都实现高度的抽象化。

过去，我们存在一些亟待提升的问题：和场景的抽象化背后的技术体系和技术框架割裂，从研发模式到渲染方案上都自成体系，以致业务受技术隔离。如一个活动跨频道、跨营销运作，带来额外较大的研发成本。

这就让我们必须站在全局的视角来讲技术框架标准化，将元件、组件以及模块进行标准化，今天所有无论是中后台也好，C端页面也好，以服务化标准化的方式提升研发效率和质量。

制定这个规范说容易也不容易，容易的原因是这个规范看起来就是原来的规范，不容易的点是背后大量的细节问题实际上经过了十次以上的对焦，比如模块应该是单端的还是多端的这个问题，里里外外至少讨论了5次以上。

### 4.5 模块规范背后的原则

1. 模块规范应该是跨终端、跨容器的，比如当前的业务场景下，同个模块应该可以能够做到在PC端、mobile web端、小程序容器上渲染。当然，模块开发者还是可以选择只开发一个端，这是由模块所属业务场景决定的；
2. 模块规范应该包含国际化的能力，这也是国内外业务模块互通的前提；
3. 模块规范应该有服务端渲染的能力，服务端渲染始终是性能优化的重点，需要提供前端定制服务端模版的能力。
4. 模块规范应该包含数据模型规范，模块开发者应该面向标准数据模型开发，而不是面向业务数据开发，不然就是一次性模块，而一次性模块就丢失了模块化真正的意义。

后续会通过版本化增量更新，搭建平台本身也会对模块规范进行约束，确保模块的流通能力。

### 4.6 不止于规范

为了确保模块规范可以正确落地，需要统一提供模块脚手架、构建器及发布流程，既在开始的时候做正确的引导，在提交后也有规范的检查。提供更加集成化的研发模式，提升模块开发者的研发体验。

## 五、统一前端模块中心

首先，统一模块中心，并不代表模块中心会解决所有模块的问题，比如搭建平台有面向业务的模块中心，也会有基于活动管理的模块中心。而统一模块中心核心解决的是开发者对于模块的管理能力，定位是一个基础的模块库。

### 5.1 模块发布链路

最早在设计模块发布链路的时候，确定了以npm为中心的托管模式，也就确定了依赖声明都通过dependences，跟社区保持一致。

在工程发布平台的支持下，模块中心建设模块发布链路和组件发布链路。分两条链路核心的原因是模块不需要发布npm仓库，实际处理流程是一样的，纯粹只是构建的流程不同，CMD的构建结果发布到npm本身也并无太大的意义。而且发布到CDN后的路径也会有一些区别。

CDN assets本身是包含来日常和线上环境，日常环境对于多人调试还是一个非常方便的路径。那么发布到npm也需要有对应的日常发布能力，最终产出的方案就是通过npm beta tag的方式，因为npm无法覆盖式发布，而CDN日常可以，于是设计了beta版本每次发布递增的规则，`@ali/comp-test 1.0.0-beta.1`。模块中心提供了统一的seed获取服务，可以确保构建器获取到日常最新的npm版本。

![component-build.png](/assets/component-build.png)

### 5.2 模块的生命周期管理

模块在开发者维度的生命周期简化一下就是新建->代码发布->审核->版本切换。这个流程基本上可以在各个业务之间进行共用。因为模块审核背后就意味着当前审核通过的版本可以被使用，虽然不是一个立即上线的过程，但模块的质量依然需要把控，也是需要有发布的卡口。

### 5.3 solution的管理能力

solution是页面的容器，包含了页面的头尾设置、统一的数据加载方案、统一的模块加载方式。

早期的solution主要是以xtpl代码为主，简单的对搭建结果进行循环，然后把模块include进来。随着个性化的引入，模块的渲染已经从服务端控制转移到了前端控制，solution本身的复杂度也是指数级上升。覆盖式发布也变成了一个问题，无法快速回滚，无法灰度发布，发布的生效范围也不可控。

把solution组件化，简化solution xtpl本身，只保留对solution模块的版本化引用。

后续通用的solution管理能力也会在模块中心统一提供，就不需要单独创建一个站点，只是为了管理solution。

不过solution这个机制本身，还遗留了很多问题，包括小程序到来的时候，小程序的solution怎么定义，solution和模块之间的对应关系怎么建立等等。

### 5.4 模块的“虚拟隔离”

用“虚拟隔离”的原因是模块中心本身没有做模块隔离，在上层各个搭建系统之间可以互相流通，但是这样容易造成各个搭建页面操作的稳定性。

同时，模块流通终究还是局限在一个业务域内，模块中心能保障的还是基础的流通能力。目前都会推荐上层搭建应用走站点或者分组级模块圈选，来限制搭建者使用模块的范围，确保模块的可用性。

### 5.5 模块中心的模块输出能力

模块一定程度上是可以拥有业务属性的，推荐上层搭建应用自建业务的模块中心。多个模块中心也就意味着要以此作为基础，有对外输出模块的能力，下图就是模块中心向共享平台供给模块的方式。

![module-out.png](/assets/module-out.png)
