# 前端搭建系列-页面渲染服务

在页面搭建的时候，同时需要配套一个高性能、高可用的服务端页面渲染服务。

## 一、部署结构
 
 ![site-render.png](/assets/site-render.png)

### 1.3 请求的核心流程

1. 用户端发起请求，请求到CDN的边缘节点。
2. CDN查询当前节点是否有缓存，如果有直接返回给用户；
3. 如果没有缓存会向源站服务器发起请求；
4. 源站服务器收到CDN的请求后，根据URL信息路由到对应的OSS页面文件，执行页面渲染逻辑；
5. 源站服务器执行完渲染逻辑返回给CDN；
6. CDN把源站服务器返回的结果返回给用户，并将结果缓存下来。

CDN承载着流量和并发的压力，源站服务器在每次页面CDN缓存过期回源时执行一次页面渲染。因此页面本身还是需要静态化能够被缓存的。默认的2分钟缓存时间，让一些非个性化的数据也能够及时更新。

## 二、核心能力

源站服务器核心能力包括：1.模版渲染；2.扩展指令。

* 模版渲染：是以Xtemplate模版引擎为基础的模版文件的渲染，将模版文件与数据结合形成页面的HTML。

* 扩展指令：又分为两类，第一类是代码打包相关的如placeholder、seed、feloader、require这类指令。借助这些打包指令可以实现模块依赖资源的combo（js、css）的生成，以及基于feloader实现模块的异步加载。在native场景下，可以将页面的代码直接打包输出为一个jsbundle。另一类指令是诸如utils、system、redirect、rewrite这类工具指令，工具指令用于JSON解析、时间判断、环境判断、页面下线跳转之类的场景。

基于以上能力，能够灵活组合出多种终端页面渲染方案。

## 三、源站文件类型

源站当前有Page、Fragment、Config、Section、Solution、Module等文件类型。

* Page：用来存放页面的信息，比如页面的Title、模块列表、页面归属的分组、页面的插件信息；
* Fragment：是代码片段，用来跨页面的代码片段共享；
* Section： 区块，用来跨页面共用的模块组；
* Config：存放配置，通常用来存放页面分组相关的信息；
* Solution：是页面的Layout、页面的核心打包逻辑、页面初始化渲染逻辑所在；
* Module：模块，包含模块的代码、seed（模块依赖关系）等；

## 四、渲染核心流程

渲染服务器收到来自CDN的回源请求后，会根据页面的URL信息定位到页面的文件，解析后得到页面信息，从而得到下一步页面使用的Solution文件，执行Solution中的模版渲染逻辑，打包出页面的代码。在solution执行过程中会加载页面的依赖，比如fragment、module、section。可以看到solution是页面渲染核心逻辑所在，而每一次回源执行一次的机制，可以让引用solution的页面组统一随着solution发布而更新。

## 五、文件缓存与地区化文件同步

由于渲染过程中会存在拉取很多依赖文件的过程，会使得页面渲染变得非常的满，所以渲染服务器在内部做了文件的缓存。对于版本化的文件如模块，这类模块本身带有版本，发布完内容就不会变化了，会缓存很长时间。而对于覆盖式发布的文件，比如页面、Config会缓存较短的时间，以保证页面发布后能够更新。目前页面发布完没法立刻生效，一方面是CDN做了页面级渲染结果的缓存，另一个方面也是因为渲染服务器本身对依赖文件也做了机器缓存。

随着全球化的推进，为了加速页面的渲染速度，渲染服务器要考虑跨国节点部署，对应存储的OSS文件也需要扩展多个地区，可以利用OSS的镜像回源的功能实现文件按需同步的能力，如果有自己内部专线的能力，尽量走内部专线保证文件传输线路的稳定，避免直接走公网受跨国运营商线路波动的影响。

## 六、后续规划

渲染服务器回源时动态打包的方案，本身非常的灵活。然而在线动态打包始终无法根治的问题：
1. 冷启动：所有缓存都消失时，拉取依赖的时间会很长；
2. 无法版本化：每一次发布都可能会影响所有页面的打包结果，每一次改动都要完全向前兼容，这样的维护成本非常的高。
未来期望能够将代码打包结果离线构建产出，而像placeholder、require、seed这些打包相关的指令做的事情将被废弃引导到离线构建流程，渲染服务器运行时将变得非常的轻量级，同时因为离线构建不用过分在乎时间，将有机会做更多的事情。

